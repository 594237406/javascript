1. 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，
也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。
为此，引用类型的值是按引用访问的①。

    在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。
ECMAScript 放弃了这一传统。

2. 参数按值传递，即使是引用类型
    ```
    function setName(obj) {
     obj.name = "Nicholas";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"
    ```

    以上代码中创建一个对象，并将其保存在了变量 person 中。然后，这个变量被传递到 setName()
    函数中之后就被复制给了 obj。在这个函数内部，obj 和 person 引用的是同一个对象。换句话说，即
    使这个变量是按值传递的，obj 也会按引用来访问同一个对象。于是，当在函数内部为 obj 添加 name
    属性后，函数外部的 person 也将有所反映；因为 person 指向的对象在堆内存中只有一个，而且是全
    局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明
    参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：

     ```
    function setName(obj) {
     obj.name = "Nicholas";
     obj = new Object();
     obj.name = "Greg";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"
    ```

    这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码：一行代码为 obj
    重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给
    setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name
    属性设置为"Greg"。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值
    为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。这说明
    即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这
    个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
    
1.  执行环境及作用域
    - 执行环境：执行环境是JS中最重要的一个概念；它定义了变量和函数有权访问的其他数据
    - 变量对象：每个执行环境都有一个与之关联的变量对象；环境中定义的所有变量和函数都保存在这个对象中。我们无法直接操作这个对象，JS解析器会操作它
    - 全局执行环境：最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同而不同，在Web浏览器中，全局执行环境被认为是window对象
    - 执行环境的销毁：在某个执行环境的所有代码都执行完毕后，环境将被销毁，意味着其中所有变量和函数定义也都随之销毁；全局执行环境的销毁是在网页或浏览器关闭时执行的
    - 执行流：每个函数都有自己的执行环境；当执行流进入一个函数时，函数的环境就被推入到一个环境栈中；在函数执行完成，栈会将其环境弹出，再把控制权返还给之前的执行环境
    - 作用域链：当代码在环境中执行时，会创建变量对象的一个作用链；作用域链的作用是保证对执行环境有权访问的所有属性（变量与函数）的有序访问
    - 作用域链的前端：前端，始终都是当前执行代码所在环境的变量对象（arguments在最前,this紧跟其后，声明在最后）
    - 作用域链的后端：全局执行环境的变量对象始终都是作用域链中的最后一个对象
    - 标识符（变量、函数、参数）的解析：是沿着作用域链一级一级地搜索过程；搜索的过程，始终都是从作用域链的前端开始，逐级向后，直到找到标识符为止；搜索到最后一个环境还是找不到的话，就会导致错误发生
    - 标识符查询：查询的过程，就是一个向上搜索的过程
    
1. 垃圾回收

    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方
式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记
的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器
完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

    到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的
垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同
    