<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script>

//        而在JavaScript 中，每个对象都是从Object.prototype 对象克隆而来的，如果是这样的话，
//        我们只能得到单一的继承关系，即每个对象都继承自Object.prototype 对象，这样的对象系统显
//        然是非常受限的。
//        实际上，虽然JavaScript 的对象最初都是由Object.prototype 对象克隆而来的，但对象构造
//        器的原型并不仅限于Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象a 需
//        要借用对象b 的能力时，可以有选择性地把对象a 的构造器的原型指向对象b，从而达到继承的
//        效果。下面的代码是我们最常用的原型继承方式：
        var obj = { name: 'sven' };
        var A = function(){};
        A.prototype = obj;
        var a = new A();
        console.log( a.name ); // 输出：sven
//        我们来看看执行这段代码的时候，引擎做了哪些事情。
//         首先，尝试遍历对象a 中的所有属性，但没有找到name 这个属性。
//         查找name 属性的这个请求被委托给对象a 的构造器的原型，它被a.__proto__ 记录着并且
//        指向A.prototype，而A.prototype 被设置为对象obj。
//         在对象obj 中找到了name 属性，并返回它的值。
//        当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现：
        var A = function(){};
        A.prototype = { name: 'sven' };
        var B = function(){};
        B.prototype = new A();
        var b = new B();
        console.log( b.name ); // 输出：sven




        //new的原理
        var createObject=function(){
            var obj=new Object();
            Contructor=[].shift.call(arguments);
            obj.__proto__=Contructor.prototype;
            var ret=Contructor.apply(obj,arguments);
            return typeof ret=="object"?ret:obj;
        };

//        var p1=new Person ("lhj");
//        var p2=createObject(Person,"lhj");
        var m1= createObject(Man,"lhj");
        //console.log(p1.getName(),p2.getName());

        console.log(m1.__proto__)

//    再看这段代码执行的时候，引擎做了什么事情。
//     首先，尝试遍历对象b 中的所有属性，但没有找到name 这个属性。
//     查找name 属性的请求被委托给对象b 的构造器的原型，它被b.__proto__ 记录着并且指向
//    B.prototype，而B.prototype 被设置为一个通过new A()创建出来的对象。
//     在该对象中依然没有找到name 属性，于是请求被继续委托给这个对象构造器的原型
//    A.prototype。
//     在A.prototype 中找到了name 属性，并返回它的值。
//    和把B.prototype 直接指向一个字面量对象相比，通过B.prototype = new A()形成的原型链比
//    之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继
//    承总是发生在对象和对象之间。
//    最后还要留意一点，原型链并不是无限长的。现在我们尝试访问对象a 的address 属性。而
//    对象b 和它构造器的原型上都没有address 属性，那么这个请求会被最终传递到哪里呢？
//    实际上，当请求达到A.prototype，并且在A.prototype 中也没有找到address 属性的时候，
//    请求会被传递给A.prototype 的构造器原型Object.prototype，显然Object.prototype 中也没有
//    address 属性，但Object.prototype 的原型是null，说明这时候原型链的后面已经没有别的节点了。
//    所以该次请求就到此打住，a.address 返回undefined。
    </script>
</head>
<body>

</body>
</html>