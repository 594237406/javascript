<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script>

        //3.我们再来玩转复杂点的高阶函数，让我们看看如何用一个高阶函数的参数传递到另一个高阶函数内部
        Function.prototype.before=function(beforeFn){
            var self=this;                                       //这个this指向func对象
            return function(){
                if(typeof beforeFn=='function'){
                    beforeFn.apply(self,arguments);              //把参数传递给before高阶函数beforeFn
                    self.apply(self,arguments);
                }
                return self;
            }
        };

        Function.prototype.after=function(afterFn){
            var self=this;                                      //这个this指向before函数的返回值
            return function(){                                  //当我们调用func时，这个函数开始执行
                if(typeof afterFn=='function'){
                    //加了判断为了防止直接调用after，没有执行before函数，context为空，并且this指向window。
                    var context=self.apply(this===window?self:this,arguments);                  //before函数的返回值开始执行，我们把参数（这里是1,2,3）传递给before函数的返回值
                    afterFn.apply(!context||context===window?self:context,arguments);           //最后执行after函数
                }
            }
        };

        var func=function(){
            console.log("函数开始执行，this:"+this,"arguments:"+[].join.call(arguments,","));
        };

        func=func.before(function(){
            console.log("before开始执行，this:"+this,"arguments:"+[].join.call(arguments,","));
        }).after(function(){
            console.log("after开始执行，this:"+this,"arguments:"+[].join.call(arguments,","));
        });
        func(1,2,3);
    </script>
</head>
<body>

</body>
</html>